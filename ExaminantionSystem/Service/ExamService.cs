using ExaminantionSystem.Entities.Dtos.Choice;
using ExaminantionSystem.Entities.Dtos.Exam;
using ExaminantionSystem.Entities.Models;
using ExaminantionSystem.Entities.Shared;
using ExaminantionSystem.Entities.Wrappers;
using ExaminantionSystem.Infrastructure.Repositories;
using Microsoft.EntityFrameworkCore;

namespace ExaminantionSystem.Service
{
    public class ExamService
    {
        private readonly ExamRepository _examRepository;
        private readonly CourseRepository _courseRepository;
        private readonly QuestionRepository _questionRepository;
        private readonly Repository<ExamQuestion> _examQuestionRepository;
        private readonly InstructorRepository _instructorRepository;
        private readonly ChoiceRepository _choiceRepository;


        public ExamService(
        ExamRepository examRepository,
        CourseRepository courseRepository,
        QuestionRepository questionRepository,
        Repository<ExamQuestion> examQuestionRepository,
        InstructorRepository instructorRepository,
        ChoiceRepository choiceRepository)
        {
            _examRepository = examRepository;
            _courseRepository = courseRepository;
            _questionRepository = questionRepository;
            _examQuestionRepository = examQuestionRepository;
            _instructorRepository = instructorRepository;
            _choiceRepository = choiceRepository;
        }

        #region ExamCRUDOperation
        public async Task<Response<ExamDto>> CreateExamAsync(CreateExamDto dto, int currentUserId)
        {

            var course = await _courseRepository.GetByIdAsync(dto.CourseId);
            if (course == null)
                return Response<ExamDto>.Fail(ErrorType.NotFound,
                    new ErrorDetail("COURSE_NOT_FOUND", "Course not found"));

            if (course.InstructorId != currentUserId)
                return Response<ExamDto>.Fail(ErrorType.Forbidden,
                    new ErrorDetail("ACCESS_DENIED", "You can only create exams for your own courses"));

            // For final exams, check if one already exists
            if (dto.Type == ExamType.Final)
            {
                var existingFinalExam = _examRepository.GetAll(e => e.CourseId == dto.CourseId && e.ExamType == ExamType.Final).ToList();

                if (existingFinalExam != null)
                    return Response<ExamDto>.Fail(ErrorType.Conflict,
                        new ErrorDetail("FINAL_EXAM_EXISTS", "A final exam already exists for this course"));
            }

            var exam = new Exam
            {
                Title = dto.Title.Trim(),
                Description = dto.Description?.Trim(),
                ExamType = dto.Type,
                CourseId = dto.CourseId,
                NumberOfQuestion = dto.NumberOfQuestion,
                StartDate = dto.StartDate,
                EndDate = dto.EndDate,
                CreatedBy = currentUserId,
                IsAutoGenerated = dto.IsAutoGenerated,

            };

            await _examRepository.AddAsync(exam);
            await _examRepository.SaveChangesAsync();

            var result = new ExamDto
            {
                Id = exam.Id,
                Title = exam.Title,
                Description = exam.Description,
                Type = exam.ExamType,
                CourseId = exam.CourseId,
                CourseTitle = course.Title,
                Duration = exam.Duration,
                NumberOfQuestion = exam.NumberOfQuestion,
                IsAutoGenerated = exam.IsAutoGenerated,
            };

            return Response<ExamDto>.Success(result);
        }

        public async Task<Response<ExamDto>> UpdateExamAsync(UpdateExamDto examDto, int currentUserId)
        {
            // Get exam
            var exam = await _examRepository.GetByIdAsync(examDto.ExamId);
            if (exam == null)
                return Response<ExamDto>.Fail(ErrorType.NotFound,
                    new ErrorDetail("EXAM_NOT_FOUND", "Exam not found"));

            // Check ownership
            var course = await _courseRepository.GetByIdAsync(exam.CourseId);
            if (course.InstructorId != currentUserId)
                return Response<ExamDto>.Fail(ErrorType.Forbidden,
                    new ErrorDetail("ACCESS_DENIED", "You can only update your own exams"));

            // Update exam
            exam.Title = examDto.Title.Trim();
            exam.Description = examDto.Description?.Trim();
            exam.Duration = examDto.Duration;
            exam.UpdatedAt = DateTime.UtcNow;

            await _examRepository.UpdateAsync(exam);
            await _examRepository.SaveChangesAsync();

            var result = new ExamDto
            {
                Id = exam.Id,
                Title = exam.Title,
                Description = exam.Description,
                Type = exam.ExamType,
                CourseId = exam.CourseId,
                CourseTitle = course.Title,
                Duration = exam.Duration,
                NumberOfQuestion = exam.NumberOfQuestion,
                IsAutoGenerated = exam.IsAutoGenerated,
            };
            return Response<ExamDto>.Success(result);
        }


        public async Task<Response<bool>> DeleteExamAsync(int examId, int currentUserId)
        {
            var exam = await _examRepository.GetByIdAsync(examId);
            if (exam == null || exam.IsDeleted)
                return Response<bool>.Fail(ErrorType.NotFound,
                    new ErrorDetail("EXAM_NOT_FOUND", "Exam not found"));

            // Check ownership
            var course = await _courseRepository.GetByIdAsync(exam.CourseId);
            if (course.InstructorId != currentUserId)
                return Response<bool>.Fail(ErrorType.Forbidden,
                    new ErrorDetail("ACCESS_DENIED", "You can only delete your own exams"));

            // Check if exam has student attempts
            var hasAttempts = await _examRepository.ExamHasSubmissionsAsync(examId);

            if (hasAttempts)
                return Response<bool>.Fail(ErrorType.BusinessRule,
                    new ErrorDetail("EXAM_HAS_ATTEMPTS", "Cannot delete exam with student attempts"));

            await _examRepository.DeleteAsync(examId);
            await _examRepository.SaveChangesAsync();

            return Response<bool>.Success(true);
        }

        #endregion


        public async Task<Response<ExamWithQuestionsDto>> AutoGenerateExamQuestionsAsync(int examId, int questionsNumber)
        {
                // Get exam
                var exam = await _examRepository.GetByIdAsync(examId);
                if (exam == null)
                    return Response<ExamWithQuestionsDto>.Fail(ErrorType.NotFound,
                        new ErrorDetail("EXAM_NOT_FOUND", "Exam not found"));

                // Get all questions for this course
                var questions = await _questionRepository.GetAll(q => q.CourseId == exam.CourseId).ToListAsync();

                if (questions.Count < questionsNumber)
                    return Response<ExamWithQuestionsDto>.Fail(ErrorType.BusinessRule,
                        new ErrorDetail("INVALID_QUESTIONNUMBER", "Not enough questions available for auto-generation"));

                // Balance questions by level (40% simple, 40% medium, 20% hard)
                var simpleQuestions = questions.Where(q => q.QuestionLevel == QuestionLevel.Easy).ToList();
                var mediumQuestions = questions.Where(q => q.QuestionLevel == QuestionLevel.Medium).ToList();
                var hardQuestions = questions.Where(q => q.QuestionLevel == QuestionLevel.Hard).ToList();

                var selectedQuestions = new List<Question>();

                // Add simple questions (40%)
                var simpleCount = (int)Math.Ceiling(questionsNumber * 0.4);
                selectedQuestions.AddRange(simpleQuestions.Take(simpleCount));

                // Add medium questions (40%)
                var mediumCount = (int)Math.Ceiling(questionsNumber * 0.4);
                selectedQuestions.AddRange(mediumQuestions.Take(mediumCount));

                // Add hard questions (20%)
                var hardCount = questionsNumber - simpleCount - mediumCount;
                selectedQuestions.AddRange(hardQuestions.Take(hardCount));

                // If we don't have enough questions, fill with available ones
                if (selectedQuestions.Count < questionsNumber)
                {
                    var remaining = questionsNumber - selectedQuestions.Count;
                    var availableQuestions = questions.Except(selectedQuestions).Take(remaining);
                    selectedQuestions.AddRange(availableQuestions);
                }

                // Add exam questions using separated function
                var addResult = await AddQuestionsToExamAsync(examId, selectedQuestions);
                if (!addResult.Succeeded)
                    return Response<ExamWithQuestionsDto>.Fail(addResult.Error.Type, addResult.Error.Errors.ToArray());

                // Get the complete exam with questions and choices for response
                var examWithQuestions = await GetExamWithQuestionsAsync(examId);
                if (!examWithQuestions.Succeeded)
                    return Response<ExamWithQuestionsDto>.Fail(examWithQuestions.Error.Type, examWithQuestions.Error.Errors.ToArray());

                return Response<ExamWithQuestionsDto>.Success(examWithQuestions.Data);

        }

        //currentUserId will be admin >> for autogenerate

        private async Task<Response<bool>> AddQuestionsToExamAsync(int examId, List<Question> questions)
        {
                var examQuestions = questions.Select(q => new ExamQuestion
                {
                    ExamId = examId,
                    QuestionId = q.Id
                }).ToList();

                await _examQuestionRepository.AddRangeAsync(examQuestions);
                await _examQuestionRepository.SaveChangesAsync();

                return Response<bool>.Success(true);
        }
        
        public async Task<Response<ExamWithQuestionsDto>> GetExamWithQuestionsAsync(int examId)
        {
            
                var exam = await _examRepository.GetByIdAsync(examId);
                if (exam == null)
                    return Response<ExamWithQuestionsDto>.Fail(ErrorType.NotFound,
                        new ErrorDetail("EXAM_NOT_FOUND", "Exam not found"));

                // Get course info
                var course = await _courseRepository.GetByIdAsync(exam.CourseId);

                var instructor = await _instructorRepository.GetByIdAsync(course.InstructorId);

                // Get exam questions with manual joins
                var examQuestionIds = await _examQuestionRepository.GetAll()
                    .Where(eq => eq.ExamId == examId)
                    .Select(eq => eq.QuestionId)
                    .ToListAsync();

                var questions = await _questionRepository.GetAll()
                    .Where(q => examQuestionIds.Contains(q.Id) && !q.IsDeleted)
                    .ToListAsync();

                // Get choices for all questions
                var questionIds = questions.Select(q => q.Id).ToList();
                var choices = await _choiceRepository.GetAll()
                    .Where(c => questionIds.Contains(c.QuestionId))
                    .ToListAsync();

                var questionDtos = new List<ExamQuestionDto>();
                foreach (var question in questions)
                {
                    var questionChoices = choices.Where(c => c.QuestionId == question.Id).ToList();

                    var choiceList = questionChoices.Select(c => new ExamWithQuestionsChoicesDto
                    {
                        Id = c.Id,
                        Text = c.Text,
                        IsCorrect = c.IsCorrect,
                        QuestionId = c.QuestionId,
                    }).ToList();

                    questionDtos.Add(new ExamQuestionDto
                    {
                        QuestionId = question.Id,
                        Content = question.Content,
                        Level = question.QuestionLevel,
                        Mark = question.Mark,
                        Choices = choiceList
                    });
                }

                // Manual mapping for exam
                var result = new ExamWithQuestionsDto
                {
                    ExamId = exam.Id,
                    Title = exam.Title,
                    Description = exam.Description,
                    Type = exam.ExamType,
                    CourseId = exam.CourseId,
                    CourseTitle = course.Title,
                    Duration = exam.Duration,
                    NumberOfQuestion = exam.NumberOfQuestion,
                    IsAutoGenerated = exam.IsAutoGenerated,
                    CreatedAt = exam.CreatedAt,
                    Questions = questionDtos,
                    QuestionCount = questionDtos.Count,
                    InstructorName = instructor.FullName
                };

                return Response<ExamWithQuestionsDto>.Success(result);
            
        }

    }
}
