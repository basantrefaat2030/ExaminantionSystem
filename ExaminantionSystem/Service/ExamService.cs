using ExaminantionSystem.Entities.Dtos.Exam;
using ExaminantionSystem.Entities.Models;
using ExaminantionSystem.Entities.Shared;
using ExaminantionSystem.Entities.Wrappers;
using ExaminantionSystem.Infrastructure.Repositories;

namespace ExaminantionSystem.Service
{
    public class ExamService
    {
        private readonly ExamRepository _examRepository;
        private readonly CourseRepository _courseRepository;
        private readonly QuestionRepository _questionRepo;

        public ExamService(
        ExamRepository examRepository,
        CourseRepository courseRepository,
        QuestionRepository questionRepository)
        {
            _examRepository = examRepository;
            _courseRepository = courseRepository;
            _questionRepo = questionRepository;
        }

        public async Task<Response<ExamDto>> CreateExamAsync(CreateExamDto dto)
        {

                var course = await _courseRepository.GetByIdAsync(dto.CourseId);
                if (course == null || course.IsDeleted)
                    return Response<ExamDto>.Fail(ErrorType.NotFound,
                        new ErrorDetail("COURSE_NOT_FOUND", "Course not found"));

                //if (course.InstructorId != currentUserId)
                //    return Response<ExamDto>.Fail(ErrorType.Forbidden,
                //        new ErrorDetail("ACCESS_DENIED", "You can only create exams for your own courses"));

                // For final exams, check if one already exists
                if (dto.Type == ExamType.Final)
                {
                    var existingFinalExam =  _examRepository.GetAll(e => e.CourseId == dto.CourseId && e.ExamType == ExamType.Final).ToList();

                    if (existingFinalExam != null)
                        return Response<ExamDto>.Fail(ErrorType.Conflict,
                            new ErrorDetail("FINAL_EXAM_EXISTS", "A final exam already exists for this course"));
                }

                var exam = new Exam
                {
                    Title = dto.Title.Trim(),
                    Description = dto.Description?.Trim(),
                    ExamType = dto.Type,
                    CourseId = dto.CourseId,
                    TotalQuestions = dto.QuestionCount,
                    StartDate = dto.StartDate,
                    EndDate = dto.EndDate,
                    CreatedBy = 2,
                    IsAutomatic = dto.IsAutoGenerated,
                   
                };

                await _examRepository.AddAsync(exam);
                await _examRepository.SaveChangesAsync();

                // Add questions to exam
                if (dto.IsAutoGenerated)
                {
                    await AutoGenerateExamQuestionsAsync(exam.Id, dto.TotalQuestion);
                }
                else 
                {
                    await AddManualExamQuestionsAsync(exam.Id, dto.ManualQuestionIds, currentUserId);
                }

                var result = new ExamDto
                {
                    Id = exam.Id,
                    Title = exam.Title,
                    Description = exam.Description,
                    Type = exam.Type,
                    CourseId = exam.CourseId,
                    CourseTitle = course.Title,
                    Duration = exam.Duration,
                    TotalQuestions = exam.TotalQuestions,
                    IsAutoGenerated = exam.IsAutoGenerated,
                    CreatedAt = exam.CreatedAt,
                    QuestionCount = await _examQuestionRepository.GetAll(eq => eq.ExamId == exam.Id && !eq.IsDeleted).CountAsync(),
                    StudentCount = await _enrollmentRepository.GetAll(e => e.CourseId == exam.CourseId && !e.IsDeleted).CountAsync()
                };

                return Response<ExamDto>.Success(result);
            }

        public async Task<Response<ExamDto>> UpdateExamAsync(int examId, UpdateExamDto dto, int currentUserId)
        {
            try
            {
                // Validate DTO
                var validationErrors = ValidateDto(dto);
                if (validationErrors.Any())
                    return Response<ExamDto>.Fail(ErrorType.Validation, validationErrors.ToArray());

                // Get exam
                var exam = await _examRepository.GetByIdAsync(examId);
                if (exam == null || exam.IsDeleted)
                    return Response<ExamDto>.Fail(ErrorType.NotFound,
                        new ErrorDetail("EXAM_NOT_FOUND", "Exam not found"));

                // Check ownership
                var course = await _courseRepository.GetByIdAsync(exam.CourseId);
                if (course.InstructorId != currentUserId)
                    return Response<ExamDto>.Fail(ErrorType.Forbidden,
                        new ErrorDetail("ACCESS_DENIED", "You can only update your own exams"));

                // Update exam
                exam.Title = dto.Title.Trim();
                exam.Description = dto.Description?.Trim();
                exam.Duration = dto.Duration;
                exam.UpdatedAt = DateTime.UtcNow;
                exam.UpdatedBy = currentUserId.ToString();

                await _examRepository.UpdateAsync(exam);
                await _examRepository.SaveChangesAsync();

                var result = await MapExamToDtoAsync(exam);
                return Response<ExamDto>.Success(result);
            }
            catch (Exception ex)
            {
                return Response<ExamDto>.Fail(ErrorType.Critical,
                    new ErrorDetail("UPDATE_EXAM_ERROR", "Failed to update exam", ex.Message));
            }
        }

        public async Task<Response<bool>> DeleteExamAsync(int examId, int currentUserId)
        {
            try
            {
                var exam = await _examRepository.GetByIdAsync(examId);
                if (exam == null || exam.IsDeleted)
                    return Response<bool>.Fail(ErrorType.NotFound,
                        new ErrorDetail("EXAM_NOT_FOUND", "Exam not found"));

                // Check ownership
                var course = await _courseRepository.GetByIdAsync(exam.CourseId);
                if (course.InstructorId != currentUserId)
                    return Response<bool>.Fail(ErrorType.Forbidden,
                        new ErrorDetail("ACCESS_DENIED", "You can only delete your own exams"));

                // Check if exam has student attempts
                var hasAttempts = await _studentExamRepository
                    .GetAll(se => se.ExamId == examId && !se.IsDeleted)
                    .AnyAsync();

                if (hasAttempts)
                    return Response<bool>.Fail(ErrorType.BusinessRule,
                        new ErrorDetail("EXAM_HAS_ATTEMPTS", "Cannot delete exam with student attempts"));

                await _examRepository.DeleteAsync(examId);
                await _examRepository.SaveChangesAsync();

                return Response<bool>.Success(true);
            }
            catch (Exception ex)
            {
                return Response<bool>.Fail(ErrorType.Critical,
                    new ErrorDetail("DELETE_EXAM_ERROR", "Failed to delete exam", ex.Message));
            }
        }



        private async Task AutoGenerateExamQuestionsAsync(int examId, int totalQuestions)
        {
            // Get exam to know the course
            var exam = await _examRepository.GetByIdAsync(examId);

            // Get all questions for this course's instructor
            var questions = await _questionRepository
                .GetAll(q => q.InstructorId == exam.Course.InstructorId && !q.IsDeleted)
                .ToListAsync();

            if (questions.Count < totalQuestions)
                throw new InvalidOperationException("Not enough questions available for auto-generation");

            // Balance questions by level (40% simple, 40% medium, 20% hard)
            var simpleQuestions = questions.Where(q => q.Level == QuestionLevel.Easy).ToList();
            var mediumQuestions = questions.Where(q => q.Level == QuestionLevel.Medium).ToList();
            var hardQuestions = questions.Where(q => q.Level == QuestionLevel.Hard).ToList();

            var selectedQuestions = new List<Question>();

            // Add simple questions (40%)
            var simpleCount = (int)Math.Ceiling(totalQuestions * 0.4);
            selectedQuestions.AddRange(simpleQuestions.Take(simpleCount));

            // Add medium questions (40%)
            var mediumCount = (int)Math.Ceiling(totalQuestions * 0.4);
            selectedQuestions.AddRange(mediumQuestions.Take(mediumCount));

            // Add hard questions (20%)
            var hardCount = totalQuestions - simpleCount - mediumCount;
            selectedQuestions.AddRange(hardQuestions.Take(hardCount));

            // If we don't have enough questions, fill with available ones
            if (selectedQuestions.Count < totalQuestions)
            {
                var remaining = totalQuestions - selectedQuestions.Count;
                var availableQuestions = questions.Except(selectedQuestions).Take(remaining);
                selectedQuestions.AddRange(availableQuestions);
            }

            // Add exam questions
            var examQuestions = selectedQuestions.Select(q => new ExamQuestion
            {
                ExamId = examId,
                QuestionId = q.Id,
                CreatedBy = exam.CreatedBy
            });

            await _examQuestionRepository.AddRangeAsync(examQuestions);
            await _examQuestionRepository.SaveChangesAsync();
        }


        public async Task<Response<ExamDto>> GetExamByIdAsync(int examId, int currentUserId)
        {
            try
            {
                var exam = await _examRepository.GetByIdAsync(examId);
                if (exam == null || exam.IsDeleted)
                    return Response<ExamDto>.Fail(ErrorType.NotFound,
                        new ErrorDetail("EXAM_NOT_FOUND", "Exam not found"));

                // Check access rights
                var course = await _courseRepository.GetByIdAsync(exam.CourseId);
                if (course.InstructorId != currentUserId)
                {
                    // Check if student is enrolled
                    var isEnrolled = await _enrollmentRepository
                        .GetAll(e => e.StudentId == currentUserId && e.CourseId == exam.CourseId && !e.IsDeleted)
                        .AnyAsync();

                    if (!isEnrolled)
                        return Response<ExamDto>.Fail(ErrorType.Forbidden,
                            new ErrorDetail("ACCESS_DENIED", "You don't have access to this exam"));
                }

                var result = await MapExamToDtoAsync(exam);
                return Response<ExamDto>.Success(result);
            }
            catch (Exception ex)
            {
                return Response<ExamDto>.Fail(ErrorType.Critical,
                    new ErrorDetail("GET_EXAM_ERROR", "Failed to retrieve exam", ex.Message));
            }
        }

        public async Task<Response<PagedResponse<ExamDto>>> GetInstructorExamsAsync(int instructorId, int pageNumber = 1, int pageSize = 10)
        {
            try
            {
                var query = _examRepository.GetAll()
                    .Where(e => e.Course.InstructorId == instructorId && !e.IsDeleted)
                    .OrderByDescending(e => e.CreatedAt);

                var totalRecords = await query.CountAsync();
                var exams = await query
                    .Skip((pageNumber - 1) * pageSize)
                    .Take(pageSize)
                    .ToListAsync();

                var examDtos = new List<ExamDto>();
                foreach (var exam in exams)
                {
                    examDtos.Add(await MapExamToDtoAsync(exam));
                }

                var pagedResponse = new PagedResponse<ExamDto>(examDtos, pageNumber, pageSize, totalRecords);
                return Response<PagedResponse<ExamDto>>.Success(pagedResponse);
            }
            catch (Exception ex)
            {
                return Response<PagedResponse<ExamDto>>.Fail(ErrorType.Critical,
                    new ErrorDetail("GET_EXAMS_ERROR", "Failed to retrieve exams", ex.Message));
            }
        }

        public async Task<Response<ExamResultDto>> EvaluateExamAsync(int studentExamId)
        {
            try
            {
                var studentExam = await _studentExamRepository
                    .GetAll(se => se.Id == studentExamId && !se.IsDeleted)
                    .Include(se => se.Exam)
                    .Include(se => se.Student)
                    .Include(se => se.StudentAnswers)
                    .ThenInclude(sa => sa.Question)
                    .ThenInclude(q => q.Choices)
                    .FirstOrDefaultAsync();

                if (studentExam == null)
                    return Response<ExamResultDto>.Fail(ErrorType.NotFound,
                        new ErrorDetail("STUDENT_EXAM_NOT_FOUND", "Student exam attempt not found"));

                if (studentExam.Status != ExamStatus.Completed)
                    return Response<ExamResultDto>.Fail(ErrorType.BusinessRule,
                        new ErrorDetail("EXAM_NOT_COMPLETED", "Exam is not completed yet"));

                // Calculate score
                decimal totalScore = 0;
                decimal totalPoints = 0;
                var questionResults = new List<QuestionResultDto>();

                foreach (var answer in studentExam.StudentAnswers)
                {
                    totalPoints += answer.Question.Points;

                    var earnedPoints = answer.IsCorrect ? answer.Question.Points : 0;
                    totalScore += earnedPoints;

                    questionResults.Add(new QuestionResultDto
                    {
                        QuestionId = answer.QuestionId,
                        Content = answer.Question.Content,
                        Points = answer.Question.Points,
                        EarnedPoints = earnedPoints,
                        IsCorrect = answer.IsCorrect,
                        SelectedChoiceId = answer.ChoiceId,
                        SelectedChoiceContent = answer.Choice?.Content
                    });
                }

                var percentage = totalPoints > 0 ? (totalScore / totalPoints) * 100 : 0;

                // Update student exam with score
                studentExam.Score = totalScore;
                studentExam.Status = ExamStatus.Graded;
                studentExam.UpdatedAt = DateTime.UtcNow;

                await _studentExamRepository.UpdateAsync(studentExam);
                await _studentExamRepository.SaveChangesAsync();

                var result = new ExamResultDto
                {
                    ExamId = studentExam.ExamId,
                    ExamTitle = studentExam.Exam.Title,
                    StudentId = studentExam.StudentId,
                    StudentName = $"{studentExam.Student.FirstName} {studentExam.Student.LastName}",
                    Score = totalScore,
                    TotalPoints = totalPoints,
                    Percentage = percentage,
                    CompletedAt = studentExam.EndTime.Value,
                    QuestionResults = questionResults
                };

                return Response<ExamResultDto>.Success(result);
            }
            catch (Exception ex)
            {
                return Response<ExamResultDto>.Fail(ErrorType.Critical,
                    new ErrorDetail("EVALUATE_EXAM_ERROR", "Failed to evaluate exam", ex.Message));
            }
        }

        public async Task<Response<PagedResponse<ExamResultDto>>> GetExamResultsAsync(int examId, int currentUserId, int pageNumber = 1, int pageSize = 10)
        {
            try
            {
                // Check if user has access to exam results
                var exam = await _examRepository.GetByIdAsync(examId);
                if (exam == null || exam.IsDeleted)
                    return Response<PagedResponse<ExamResultDto>>.Fail(ErrorType.NotFound,
                        new ErrorDetail("EXAM_NOT_FOUND", "Exam not found"));

                var course = await _courseRepository.GetByIdAsync(exam.CourseId);

                if (course.InstructorId != currentUserId)
                {
                    // Students can only see their own results
                    var query = _studentExamRepository.GetAll()
                        .Where(se => se.ExamId == examId && se.StudentId == currentUserId &&
                                    se.Status == ExamStatus.Graded && !se.IsDeleted)
                        .OrderByDescending(se => se.EndTime);

                    var totalRecords = await query.CountAsync();
                    var studentExams = await query
                        .Skip((pageNumber - 1) * pageSize)
                        .Take(pageSize)
                        .ToListAsync();

                    var results = new List<ExamResultDto>();
                    foreach (var studentExam in studentExams)
                    {
                        var result = await EvaluateExamAsync(studentExam.Id);
                        if (result.Succeeded)
                            results.Add(result.Data);
                    }

                    var pagedResponse = new PagedResponse<ExamResultDto>(results, pageNumber, pageSize, totalRecords);
                    return Response<PagedResponse<ExamResultDto>>.Success(pagedResponse);
                }
                else
                {
                    // Instructors can see all results
                    var query = _studentExamRepository.GetAll()
                        .Where(se => se.ExamId == examId && se.Status == ExamStatus.Graded && !se.IsDeleted)
                        .OrderByDescending(se => se.EndTime);

                    var totalRecords = await query.CountAsync();
                    var studentExams = await query
                        .Skip((pageNumber - 1) * pageSize)
                        .Take(pageSize)
                        .ToListAsync();

                    var results = new List<ExamResultDto>();
                    foreach (var studentExam in studentExams)
                    {
                        var result = await EvaluateExamAsync(studentExam.Id);
                        if (result.Succeeded)
                            results.Add(result.Data);
                    }

                    var pagedResponse = new PagedResponse<ExamResultDto>(results, pageNumber, pageSize, totalRecords);
                    return Response<PagedResponse<ExamResultDto>>.Success(pagedResponse);
                }
            }
            catch (Exception ex)
            {
                return Response<PagedResponse<ExamResultDto>>.Fail(ErrorType.Critical,
                    new ErrorDetail("GET_EXAM_RESULTS_ERROR", "Failed to retrieve exam results", ex.Message));
            }
        }

        private async Task AddManualExamQuestionsAsync(int examId, List<int> questionIds, int currentUserId)
        {
            var exam = await _examRepository.GetByIdAsync(examId);

            // Verify all questions belong to the instructor
            var instructorQuestions = await _questionRepository
                .GetAll(q => questionIds.Contains(q.Id) && q.InstructorId == currentUserId && !q.IsDeleted)
                .ToListAsync();

            if (instructorQuestions.Count != questionIds.Count)
                throw new InvalidOperationException("Some questions don't belong to you or don't exist");

            var examQuestions = questionIds.Select(questionId => new ExamQuestion
            {
                ExamId = examId,
                QuestionId = questionId,
                CreatedBy = currentUserId.ToString()
            });

            await _examQuestionRepository.AddRangeAsync(examQuestions);
            await _examQuestionRepository.SaveChangesAsync();
        }